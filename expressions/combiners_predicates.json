{
  "description": "combiner predicate and interaction tests",
  "tests": [
    {"expr": "(operative? $if)", "expected": "#t", "note": "Primitive operative $if"},
    {"expr": "(operative? $define!)", "expected": "#t", "note": "Primitive operative $define!"},
    {"expr": "(operative? $vau)", "expected": "#t", "note": "Primitive operative $vau"},
    {"expr": "(operative? $cond)", "expected": "#t", "note": "Primitive operative $cond"},
    {"expr": "(operative? $sequence)", "expected": "#t", "note": "Primitive operative $sequence"},
    {"expr": "(operative? $lambda)", "expected": "#t", "note": "Primitive operative $lambda"},
    {"expr": "(operative? $let)", "expected": "#t", "note": "Primitive operative $let"},
    {"expr": "(operative? ($vau (x) e (eval x e)))", "expected": "#t", "note": "Compound operative created by $vau"},
    {"expr": "(operative? ($vau args env args))", "expected": "#t", "note": "Compound operative with rest params"},
    {"expr": "(operative? (unwrap ($lambda () 42)))", "expected": "#t", "note": "Unwrapped lambda yields operative"},

    {"expr": "(applicative? cons)", "expected": "#t", "note": "Primitive applicative cons"},
    {"expr": "(applicative? +)", "expected": "#t", "note": "Primitive applicative +"},
    {"expr": "(applicative? list)", "expected": "#t", "note": "Primitive applicative list"},
    {"expr": "(applicative? car)", "expected": "#t", "note": "Primitive applicative car"},
    {"expr": "(applicative? cdr)", "expected": "#t", "note": "Primitive applicative cdr"},
    {"expr": "(applicative? eval)", "expected": "#t", "note": "Primitive applicative eval"},
    {"expr": "(applicative? apply)", "expected": "#t", "note": "Primitive applicative apply"},
    {"expr": "(applicative? ($lambda () #t))", "expected": "#t", "note": "$lambda produces applicative"},
    {"expr": "(applicative? ($lambda (x y) (+ x y)))", "expected": "#t", "note": "Lambda with params is applicative"},
    {"expr": "(applicative? (wrap ($vau () #ignore 99)))", "expected": "#t", "note": "Wrapped operative is applicative"},

    {"expr": "(combiner? $if)", "expected": "#t", "note": "Operative is a combiner"},
    {"expr": "(combiner? cons)", "expected": "#t", "note": "Applicative is a combiner"},
    {"expr": "(combiner? ($vau () #ignore #inert))", "expected": "#t", "note": "Compound operative is combiner"},
    {"expr": "(combiner? ($lambda () #inert))", "expected": "#t", "note": "Lambda result is combiner"},
    {"expr": "(combiner? (wrap $if))", "expected": "#t", "note": "Wrapped primitive operative is combiner"},
    {"expr": "(combiner? (unwrap list))", "expected": "#t", "note": "Unwrapped applicative is combiner"},
    {"expr": "(combiner? 42)", "expected": "#f", "note": "Number is not a combiner"},
    {"expr": "(combiner? #t)", "expected": "#f", "note": "Boolean is not a combiner"},
    {"expr": "(combiner? (list 1 2 3))", "expected": "#f", "note": "List is not a combiner"},
    {"expr": "(combiner? (quote sym))", "expected": "#f", "note": "Symbol is not a combiner"},

    {"expr": "(operative?)", "expected": "#t", "note": "Zero args: vacuously true"},
    {"expr": "(operative? $if $vau $define!)", "expected": "#t", "note": "Multiple operatives all pass"},
    {"expr": "(operative? $if cons)", "expected": "#f", "note": "Mixed: applicative among operatives fails"},
    {"expr": "(operative? $vau 42 $if)", "expected": "#f", "note": "Non-combiner among operatives fails"},
    {"expr": "(applicative?)", "expected": "#t", "note": "Zero args: vacuously true"},
    {"expr": "(applicative? cons list car cdr)", "expected": "#t", "note": "Multiple applicatives all pass"},
    {"expr": "(applicative? cons $if list)", "expected": "#f", "note": "Operative among applicatives fails"},
    {"expr": "(applicative? + - * #f)", "expected": "#f", "note": "Non-combiner among applicatives fails"},
    {"expr": "(combiner?)", "expected": "#t", "note": "Zero args: vacuously true"},
    {"expr": "(combiner? $if cons $vau list)", "expected": "#t", "note": "Mixed operatives and applicatives all pass"},

    {"expr": "(map operative? (list $if $vau cons ($lambda () 1)))", "expected": "(#t #t #f #f)", "note": "Map operative? over list of combiners"},
    {"expr": "(map applicative? (list $if $vau cons ($lambda () 1)))", "expected": "(#f #f #t #t)", "note": "Map applicative? over list of combiners"},
    {"expr": "(map combiner? (list $if cons 42 #t ()))", "expected": "(#t #t #f #f #f)", "note": "Map combiner? over mixed values"},
    {"expr": "(filter operative? (list $if cons $vau list $define!))", "expected": "($if $vau $define!)", "note": "Filter operatives from combiners"},
    {"expr": "(filter applicative? (list $if cons $vau list $define!))", "expected": "(cons list)", "note": "Filter applicatives from combiners"},
    {"expr": "(filter combiner? (list $if 1 cons 2 $vau 3))", "expected": "($if cons $vau)", "note": "Filter combiners from mixed list"},
    {"expr": "(apply operative? (list $if $vau $cond))", "expected": "#t", "note": "Apply operative? to list of operatives"},
    {"expr": "(apply applicative? (list cons list +))", "expected": "#t", "note": "Apply applicative? to list of applicatives"},
    {"expr": "(apply combiner? (list $if cons ($lambda () 1)))", "expected": "#t", "note": "Apply combiner? to mixed combiners"},
    {"expr": "(reduce (list $if cons $vau +) ($lambda (x acc) (and? acc (combiner? x))) #t)", "expected": "#t", "note": "Reduce to check all are combiners"}
  ]
}
