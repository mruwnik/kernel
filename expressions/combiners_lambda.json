{
  "description": "$lambda applicative tests",
  "tests": [
    {
      "expr": "(($lambda () 42))",
      "expected": "42",
      "note": "Zero parameters, returns constant"
    },
    {
      "expr": "(($lambda () #inert))",
      "expected": "#inert",
      "note": "Zero parameters, returns #inert"
    },
    {
      "expr": "(($lambda (x) x) 42)",
      "expected": "42",
      "note": "Single parameter identity"
    },
    {
      "expr": "(($lambda (x) (+ x 1)) 5)",
      "expected": "6",
      "note": "Single parameter with body computation"
    },
    {
      "expr": "(($lambda (a b) a) 1 2)",
      "expected": "1",
      "note": "Two parameters, return first"
    },
    {
      "expr": "(($lambda (a b) b) 1 2)",
      "expected": "2",
      "note": "Two parameters, return second"
    },
    {
      "expr": "(($lambda (a b) (+ a b)) 3 4)",
      "expected": "7",
      "note": "Two parameters, sum"
    },
    {
      "expr": "(($lambda (a b c) (list a b c)) 1 2 3)",
      "expected": "(1 2 3)",
      "note": "Three parameters"
    },
    {
      "expr": "(($lambda (a b c d) (+ a (+ b (+ c d)))) 1 2 3 4)",
      "expected": "10",
      "note": "Four parameters"
    },
    {
      "expr": "(($lambda (a b c d e) (list a c e)) 1 2 3 4 5)",
      "expected": "(1 3 5)",
      "note": "Five parameters, select odd positions"
    },
    {
      "expr": "(($lambda args args) 1 2 3)",
      "expected": "(1 2 3)",
      "note": "Rest parameter captures all args as list"
    },
    {
      "expr": "(($lambda args args))",
      "expected": "()",
      "note": "Rest parameter with no arguments"
    },
    {
      "expr": "(($lambda args (length args)) 1 2 3 4 5)",
      "expected": "5",
      "note": "Rest parameter, compute length"
    },
    {
      "expr": "(($lambda (a . rest) rest) 1 2 3)",
      "expected": "(2 3)",
      "note": "One fixed, rest captures remainder"
    },
    {
      "expr": "(($lambda (a . rest) a) 1 2 3)",
      "expected": "1",
      "note": "One fixed, access fixed param"
    },
    {
      "expr": "(($lambda (a . rest) rest) 1)",
      "expected": "()",
      "note": "One fixed, empty rest"
    },
    {
      "expr": "(($lambda (a b . rest) rest) 1 2 3 4 5)",
      "expected": "(3 4 5)",
      "note": "Two fixed, rest captures three"
    },
    {
      "expr": "(($lambda (a b . rest) (list a b)) 1 2 3 4)",
      "expected": "(1 2)",
      "note": "Two fixed, ignore rest"
    },
    {
      "expr": "(($lambda (a b c . rest) (cons (+ a (+ b c)) rest)) 1 2 3 4 5)",
      "expected": "(6 4 5)",
      "note": "Three fixed with rest, mixed use"
    },
    {
      "expr": "(($lambda (x . xs) (cons x (cons x xs))) 1 2 3)",
      "expected": "(1 1 2 3)",
      "note": "Rest parameter, duplicate first"
    },
    {
      "expr": "(($lambda ((a b)) (+ a b)) (list 1 2))",
      "expected": "3",
      "note": "Destructure list into two elements"
    },
    {
      "expr": "(($lambda ((a . b)) a) (cons 1 2))",
      "expected": "1",
      "note": "Destructure pair, get car"
    },
    {
      "expr": "(($lambda ((a . b)) b) (cons 1 2))",
      "expected": "2",
      "note": "Destructure pair, get cdr"
    },
    {
      "expr": "(($lambda ((a b) c) (list a b c)) (list 1 2) 3)",
      "expected": "(1 2 3)",
      "note": "Mixed: destructure first arg, plain second"
    },
    {
      "expr": "(($lambda ((a b) (c d)) (+ a (+ b (+ c d)))) (list 1 2) (list 3 4))",
      "expected": "10",
      "note": "Two destructured arguments"
    },
    {
      "expr": "(($lambda (((a))) a) (list (list 42)))",
      "expected": "42",
      "note": "Deeply nested destructuring"
    },
    {
      "expr": "(($lambda ((a . rest)) rest) (list 1 2 3))",
      "expected": "(2 3)",
      "note": "Destructure with rest in pattern"
    },
    {
      "expr": "(($lambda ((#ignore b)) b) (list 1 2))",
      "expected": "2",
      "note": "Destructure with #ignore"
    },
    {
      "expr": "(($lambda (((a b) c)) (list a b c)) (list (list 1 2) 3))",
      "expected": "(1 2 3)",
      "note": "Nested destructure inside list"
    },
    {
      "expr": "(($lambda ((a (b c))) (list a b c)) (list 1 (list 2 3)))",
      "expected": "(1 2 3)",
      "note": "Nested destructure in second position"
    },
    {
      "expr": "(($lambda (x) x) (+ 1 2))",
      "expected": "3",
      "note": "Argument is evaluated before binding"
    },
    {
      "expr": "(($lambda (x) x) (* 3 4))",
      "expected": "12",
      "note": "Multiplication evaluated in argument"
    },
    {
      "expr": "(($lambda (a b) (+ a b)) (+ 1 1) (+ 2 2))",
      "expected": "6",
      "note": "Multiple arguments evaluated"
    },
    {
      "expr": "(($lambda (x) (+ x 1)) (($lambda (y) (* y 2)) 5))",
      "expected": "11",
      "note": "Nested lambda call as argument"
    },
    {
      "expr": "(($lambda (a b c) (list a b c)) (car (list 1 2)) (cdr (list 3 4)) (cons 5 6))",
      "expected": "(1 (4) (5 . 6))",
      "note": "Complex expressions as arguments"
    },
    {
      "expr": "(($lambda (x) (+ x x)) (+ 1 2 3))",
      "expected": "12",
      "note": "Variadic + evaluated in argument"
    },
    {
      "expr": "(($lambda (f x) (f x)) ($lambda (n) (* n n)) 5)",
      "expected": "25",
      "note": "Lambda as argument, then applied"
    },
    {
      "expr": "(($lambda args args) (+ 1 0) (+ 2 0) (+ 3 0))",
      "expected": "(1 2 3)",
      "note": "Rest args all evaluated"
    },
    {
      "expr": "(($lambda (x) x) (list 1 2 3))",
      "expected": "(1 2 3)",
      "note": "List constructor evaluated as argument"
    },
    {
      "expr": "(($lambda (x) x) ($if #t 42 99))",
      "expected": "42",
      "note": "Conditional evaluated as argument"
    },
    {
      "expr": "($let ((x 10)) (($lambda () x)))",
      "expected": "10",
      "note": "Closure captures outer variable"
    },
    {
      "expr": "($let ((x 5)) (($lambda (y) (+ x y)) 3))",
      "expected": "8",
      "note": "Closure with parameter"
    },
    {
      "expr": "($let ((x 1)) ($let ((f ($lambda () x))) ($let ((x 2)) (f))))",
      "expected": "1",
      "note": "Lexical scoping: captures definition-time binding"
    },
    {
      "expr": "($let ((a 1) (b 2)) (($lambda (c) (+ a (+ b c))) 3))",
      "expected": "6",
      "note": "Multiple outer variables captured"
    },
    {
      "expr": "(applicative? (($lambda (x) ($lambda (y) (+ x y))) 10))",
      "expected": "#t",
      "note": "Returns closure (curried function) - verify it's an applicative"
    },
    {
      "expr": "((($lambda (x) ($lambda (y) (+ x y))) 10) 5)",
      "expected": "15",
      "note": "Curried function application"
    },
    {
      "expr": "($let ((make-adder ($lambda (n) ($lambda (x) (+ x n))))) ((make-adder 5) 10))",
      "expected": "15",
      "note": "Factory function creating closures"
    },
    {
      "expr": "($let ((x 100)) ($let ((f ($lambda (x) ($lambda () x)))) ((f 42))))",
      "expected": "42",
      "note": "Parameter shadows outer binding in closure"
    },
    {
      "expr": "($let ((counter 0)) ($let ((inc ($lambda () ($set! counter (+ counter 1)) counter))) (list (inc) (inc) (inc))))",
      "expected": "(1 2 3)",
      "note": "Closure with mutable state"
    },
    {
      "expr": "($letrec ((fact ($lambda (n) ($if (=? n 0) 1 (* n (fact (- n 1))))))) (fact 5))",
      "expected": "120",
      "note": "Recursive closure via $letrec"
    }
  ]
}
